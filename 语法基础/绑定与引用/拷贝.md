# 拷贝特性

在下列代码中：

```rs
let a: i32 = 100;
let b = a;
println!("{}", a);
```

对于实现 Copy 特性的变量，在 move 时会拷贝资源到新内存区域，并把新内存区域的资源 binding 为 b：

```s
Before move:
a <=> 内存(地址：A，内容：100)
After move:
a <=> 内存(地址：A，内容：100)
b <=> 内存(地址：B，内容：100)
```

move 前后的 a 和 b 对应资源内存的地址不同。在 Rust 中，基本数据类型(Primitive Types)均实现了 Copy 特性，包括 i8, i16, i32, i64, usize, u8, u16, u32, u64, f32, f64, (), bool, char 等等。

# 浅拷贝与深拷贝

很多面向对象编程语言中“浅拷贝”和“深拷贝”的区别类似。对于基本数据类型来说，“深拷贝”和“浅拷贝“产生的效果相同。对于引用对象类型来说，”浅拷贝“更像仅仅拷贝了对象的内存地址。 如果我们想实现对`String`的”深拷贝“怎么办？ 可以直接调用`String`的 Clone 特性实现对内存的值拷贝而不是简单的地址拷贝。

```rust
{
    let a: String = String::from("xyz");
    let b = a.clone();  // <-注意此处的clone
    println!("{}", a);
}
```

这个时候可以编译通过，并且成功打印"xyz"。clone 后的效果等同如下：

> **Before move:**
> a <=> 内存(地址：**A**，内容："xyz")
> **After move:**
> a <=> 内存(地址：**A**，内容："xyz")
> b <=> 内存(地址：**B**，内容："xyz")

注意，然后 a 和 b 对应的资源值相同，但是内存地址并不一样。

# 高级 Copy 特性

Copy 特性定义在标准库 std::marker::Copy 中：

```rs
pub trait Copy: Clone { }
```

一旦一种类型实现了 Copy 特性，这就意味着这种类型可以通过的简单的位(bits)拷贝实现拷贝。从前面知识我们知道“绑定”存在 move 语义（所有权转移），但是，一旦这种类型实现了 Copy 特性，会先拷贝内容到新内存区域，然后把新内存区域和这个标识符做绑定。

哪些情况下我们自定义的类型（如某个 Struct 等）可以实现 Copy 特性？ 只要这种类型的属性类型都实现了 Copy 特性，那么这个类型就可以实现 Copy 特性。 例如：

```rs
struct Foo {  //可实现Copy特性
    a: i32,
    b: bool,
}

struct Bar {  //不可实现Copy特性
    l: Vec<i32>,
}
```

因为 Foo 的属性 a 和 b 的类型 i32 和 bool 均实现了 Copy 特性，所以 Foo 也是可以实现 Copy 特性的。但对于 Bar 来说，它的属性 l 是 Vec<T>类型，这种类型并没有实现 Copy 特性，所以 Bar 也是无法实现 Copy 特性的。

有两种方式可以实现 Copy 特性：

- 通过 derive 让 Rust 编译器自动实现

```rs
 #[derive(Copy, Clone)]
 struct Foo {
     a: i32,
     b: bool,
 }
```

编译器会自动检查 Foo 的所有属性是否实现了 Copy 特性，一旦检查通过，便会为 Foo 自动实现 Copy 特性。

- 手动实现 Clone 和 Copy trait

```rs
#[derive(Debug)]
 struct Foo {
     a: i32,
     b: bool,
 }
 impl Copy for Foo {}
 impl Clone for Foo {
     fn clone(&self) -> Foo {
         Foo{a: self.a, b: self.b}
     }
 }
 fn main() {
     let x = Foo{ a: 100, b: true};
     let mut y = x;
     y.b = false;

     println!("{:?}", x);  //打印：Foo { a: 100, b: true }
     println!("{:?}", y);  //打印：Foo { a: 100, b: false }
 }
```

从结果我们发现 let mut y = x 后，x 并没有因为所有权 move 而出现不可访问错误。 因为 Foo 继承了 Copy 特性和 Clone 特性，所以例子中我们实现了这两个特性。
