# 所有权（Ownership）

所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。对于一般的编程语言，通常会先声明一个变量，然后初始化它。例如在 C 语言中：

```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```

变量 a 和 c 都是局部变量，函数结束后将局部变量 a 的地址返回，但局部变量 a 存在栈中，在离开作用域后，局部变量所申请的栈上内存都会被系统回收，从而造成了 Dangling Pointer 的问题。这是一个非常典型的内存安全问题。很多编程语言都存在类似这样的内存安全问题。再来看变量 c，c 的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，我们可能不再想使用这个字符串，但 xyz 只有当整个程序结束后系统才能回收这片内存。

首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则：

- Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。
- 值在任一时刻有且只有一个所有者。
- 当所有者（变量）离开作用域，这个值将被丢弃。

# 绑定（Binding）

首先必须强调下，准确地说 Rust 中并没有变量这一概念，而应该称为标识符，目标资源(内存，存放 value)绑定到这个标识符：

```rs
{
    let x: i32;       // 标识符x, 没有绑定任何资源
    let y: i32 = 100; // 标识符y，绑定资源100
}
```

在如下的 Rust 代码中：

```rs
{
    let a: i32;
    println!("{}", a);
}
```

上面定义了一个 i32 类型的标识符 a，如果你直接 println!，你会收到一个 error 报错：

> error: use of possibly uninitialized variable: a

这是因为 Rust 并不会像其他语言一样可以为变量默认初始化值，Rust 明确规定变量的初始值必须由程序员自己决定。

```rs
{
    let a: i32;
    a = 100; //必须初始化a
    println!("{}", a);
}
```

其实，let 关键字并不只是声明变量的意思，它还有一层特殊且重要的概念：绑定。通俗的讲，let 关键字可以把一个标识符和一段内存区域做“绑定”，绑定后，这段内存就被这个标识符所拥有，这个标识符也成为这段内存的唯一所有者。所以，a = 100 发生了这么几个动作，首先在栈内存上分配一个 i32 的资源，并填充值 100，随后，把这个资源与 a 做绑定，让 a 成为资源的所有者(Owner)。

# 作用域

像 C 语言一样，Rust 通过 {} 大括号定义作用域，作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：

```rs
{
    {
        let a: i32 = 100;
    }
    println!("{}", a);
}
```

编译后会得到如下 error 错误：

> b.rs:3:20: 3:21 error: unresolved name a [E0425] b.rs:3 println!("{}", a);

像 C 语言一样，在局部变量离开作用域后，变量随即会被销毁；但不同是，Rust 会连同变量绑定的内存，不管是否为常量字符串，连同所有者变量一起被销毁释放。所以上面的例子，a 销毁后再次访问 a 就会提示无法找到变量 a 的错误。这些所有的一切都是在编译过程中完成的。

## 内存与分配

字符串字面值，即被硬编码进程序里的字符串值；字符串字面值是很方便的，不过它们并不适合使用文本的每一种场景。原因之一就是它们是不可变的。另一个原因是并非所有字符串的值都能在编写代码时就知道。而 String 类型被分配到堆上，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面值来创建 String，如下：

```rs
let s = String::from("hello");

let mut s = String::from("hello");

s.push_str(", world!"); // push_str() 在字符串后追加字面值

println!("{}", s); // 将打印 `hello, world!`
```

就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。

对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：

- 必须在运行时向操作系统请求内存。
- 需要一个当我们处理完 `String` 时将内存返回给操作系统的方法。

# 移动语义（move）

先看如下代码：

```rust
{
    let a: String = String::from("xyz");
    let b = a;
    println!("{}", a);
}
```

编译后会得到如下的报错：

> c.rs:4:20: 4:21 error: use of moved value: `a` [E0382] c.rs:4 println!("{}", a);

错误的意思是在`println`中访问了被`moved`的变量`a`。那为什么会有这种报错呢？具体含义是什么？ 在 Rust 中，和“绑定”概念相辅相成的另一个机制就是“转移 move 所有权”，意思是，**可以把资源的所有权(ownership)从一个绑定转移（move）成另一个绑定**，这个操作同样通过`let`关键字完成，和绑定不同的是，`=`两边的左值和右值均为两个标识符：

```rust
语法：
    let 标识符A = 标识符B;  // 把“B”绑定资源的所有权转移给“A”
```

move 前后的内存示意如下：

> **Before move:**
> a <=> 内存(地址：**A**，内容："xyz")
> **After move:**
> a
> b <=> 内存(地址：**A**，内容："xyz")

被 move 的变量不可以继续被使用。否则提示错误`error: use of moved value`。这里有些人可能会疑问，move 后，如果变量 A 和变量 B 离开作用域，所对应的内存会不会造成“Double Free”的问题？答案是否定的，Rust 规定，只有资源的所有者销毁后才释放内存，而无论这个资源是否被多次`move`，同一时刻只有一个`owner`，所以该资源的内存也只会被`free`一次。通过这个机制，就保证了内存安全。

let 绑定会发生所有权转移的情况，但 ownership 转移却因为资源类型是否实现 Copy 特性而行为不同：

```rs
let x: T = something;
let y = x;
```

- 类型`T`没有实现`Copy`特性：`x`所有权转移到`y`。
- 类型`T`实现了`Copy`特性：拷贝`x`所绑定的`资源`为`新资源`，并把`新资源`的所有权绑定给`y`，`x`依然拥有原资源的所有权。

## move 关键字

move 关键字常用在闭包中，强制闭包获取所有权。

```rs
fn main() {
    let x: i32 = 100;
    let some_closure = move |i: i32| i + x;
    let y = some_closure(2);
    println!("x={}, y={}", x, y);
}

// 结果： x=100, y=102
```

上例中使不使用 move 对结果都没什么影响，因为 x 绑定的资源是 i32 类型，属于 primitive type，实现了 Copy trait，所以在闭包使用 move 的时候，是先 copy 了 x ，在 move 的时候是 move 了这份 clone 的 x，所以后面的 println!引用 x 的时候没有报错。

```rs
fn main() {
    let mut x: String = String::from("abc");
    let mut some_closure = move |c: char| x.push(c);
    let y = some_closure('d');
    println!("x={:?}", x);
}

报错： error: use of moved value: x [E0382]
:5 println!("x={:?}", x);
```

这是因为 move 关键字，会把闭包中的外部变量的所有权 move 到包体内，发生了所有权转移的问题，所以 println 访问 x 会如上错误。如果我们去掉 println 就可以编译通过。那么，如果我们想在包体外依然访问 x，即 x 不失去所有权，怎么办？

```rust
fn main() {
	let mut x: String = String::from("abc");
	{
    	let mut some_closure = |c: char| x.push(c);
	    some_closure('d');
	}
	println!("x={:?}", x);  //成功打印：x="abcd"
}
```

我们只是去掉了 move，去掉 move 后，包体内就会对 `x` 进行了可变借用，而不是剥夺 `x` 的所有权，细心的同学还注意到我们在前后还加了 `{}` 大括号作用域，是为了作用域结束后让可变借用失效，这样 `println` 才可以成功访问并打印我们期待的内容。

# 克隆（Clone）
