# 所有权（Ownership）

对于一般的编程语言，通常会先声明一个变量，然后初始化它。例如在 C 语言中：

```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```

变量 a 和 c 都是局部变量，函数结束后将局部变量 a 的地址返回，但局部变量 a 存在栈中，在离开作用域后，局部变量所申请的栈上内存都会被系统回收，从而造成了 Dangling Pointer 的问题。这是一个非常典型的内存安全问题。很多编程语言都存在类似这样的内存安全问题。再来看变量 c，c 的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，我们可能不再想使用这个字符串，但 xyz 只有当整个程序结束后系统才能回收这片内存。

# 绑定（Binding）

首先必须强调下，准确地说 Rust 中并没有变量这一概念，而应该称为标识符，目标资源(内存，存放 value)绑定到这个标识符：

```rs
{
    let x: i32;       // 标识符x, 没有绑定任何资源
    let y: i32 = 100; // 标识符y，绑定资源100
}
```

在如下的 Rust 代码中：

```rs
{
    let a: i32;
    println!("{}", a);
}
```

上面定义了一个 i32 类型的标识符 a，如果你直接 println!，你会收到一个 error 报错：

> error: use of possibly uninitialized variable: a

这是因为 Rust 并不会像其他语言一样可以为变量默认初始化值，Rust 明确规定变量的初始值必须由程序员自己决定。

```rs
{
    let a: i32;
    a = 100; //必须初始化a
    println!("{}", a);
}
```

其实，let 关键字并不只是声明变量的意思，它还有一层特殊且重要的概念：绑定。通俗的讲，let 关键字可以把一个标识符和一段内存区域做“绑定”，绑定后，这段内存就被这个标识符所拥有，这个标识符也成为这段内存的唯一所有者。所以，a = 100 发生了这么几个动作，首先在栈内存上分配一个 i32 的资源，并填充值 100，随后，把这个资源与 a 做绑定，让 a 成为资源的所有者(Owner)。

# 作用域

像 C 语言一样，Rust 通过 {} 大括号定义作用域：

```rs
{
    {
        let a: i32 = 100;
    }
    println!("{}", a);
}
```

编译后会得到如下 error 错误：

> b.rs:3:20: 3:21 error: unresolved name a [E0425] b.rs:3 println!("{}", a);

像 C 语言一样，在局部变量离开作用域后，变量随即会被销毁；但不同是，Rust 会连同变量绑定的内存，不管是否为常量字符串，连同所有者变量一起被销毁释放。所以上面的例子，a 销毁后再次访问 a 就会提示无法找到变量 a 的错误。这些所有的一切都是在编译过程中完成的。

# 移动语义（move）

先看如下代码：

```rust
{
    let a: String = String::from("xyz");
    let b = a;
    println!("{}", a);
}
```

编译后会得到如下的报错：

> c.rs:4:20: 4:21 error: use of moved value: `a` [E0382] c.rs:4 println!("{}", a);

错误的意思是在`println`中访问了被`moved`的变量`a`。那为什么会有这种报错呢？具体含义是什么？ 在 Rust 中，和“绑定”概念相辅相成的另一个机制就是“转移 move 所有权”，意思是，**可以把资源的所有权(ownership)从一个绑定转移（move）成另一个绑定**，这个操作同样通过`let`关键字完成，和绑定不同的是，`=`两边的左值和右值均为两个标识符：

```rust
语法：
    let 标识符A = 标识符B;  // 把“B”绑定资源的所有权转移给“A”
```

move 前后的内存示意如下：

> **Before move:**
> a <=> 内存(地址：**A**，内容："xyz")
> **After move:**
> a
> b <=> 内存(地址：**A**，内容："xyz")

被 move 的变量不可以继续被使用。否则提示错误`error: use of moved value`。这里有些人可能会疑问，move 后，如果变量 A 和变量 B 离开作用域，所对应的内存会不会造成“Double Free”的问题？答案是否定的，Rust 规定，只有资源的所有者销毁后才释放内存，而无论这个资源是否被多次`move`，同一时刻只有一个`owner`，所以该资源的内存也只会被`free`一次。通过这个机制，就保证了内存安全。

let 绑定会发生所有权转移的情况，但 ownership 转移却因为资源类型是否实现 Copy 特性而行为不同：

```rs
let x: T = something;
let y = x;
```

- 类型`T`没有实现`Copy`特性：`x`所有权转移到`y`。
- 类型`T`实现了`Copy`特性：拷贝`x`所绑定的`资源`为`新资源`，并把`新资源`的所有权绑定给`y`，`x`依然拥有原资源的所有权。

## move 关键字

move 关键字常用在闭包中，强制闭包获取所有权。

```rs
fn main() {
    let x: i32 = 100;
    let some_closure = move |i: i32| i + x;
    let y = some_closure(2);
    println!("x={}, y={}", x, y);
}

// 结果： x=100, y=102
```

上例中使不使用 move 对结果都没什么影响，因为 x 绑定的资源是 i32 类型，属于 primitive type，实现了 Copy trait，所以在闭包使用 move 的时候，是先 copy 了 x ，在 move 的时候是 move 了这份 clone 的 x，所以后面的 println!引用 x 的时候没有报错。

```rs
fn main() {
    let mut x: String = String::from("abc");
    let mut some_closure = move |c: char| x.push(c);
    let y = some_closure('d');
    println!("x={:?}", x);
}

报错： error: use of moved value: x [E0382]
:5 println!("x={:?}", x);
```

这是因为 move 关键字，会把闭包中的外部变量的所有权 move 到包体内，发生了所有权转移的问题，所以 println 访问 x 会如上错误。如果我们去掉 println 就可以编译通过。那么，如果我们想在包体外依然访问 x，即 x 不失去所有权，怎么办？

```rust
fn main() {
	let mut x: String = String::from("abc");
	{
    	let mut some_closure = |c: char| x.push(c);
	    some_closure('d');
	}
	println!("x={:?}", x);  //成功打印：x="abcd"
}
```

我们只是去掉了 move，去掉 move 后，包体内就会对 `x` 进行了可变借用，而不是剥夺 `x` 的所有权，细心的同学还注意到我们在前后还加了 `{}` 大括号作用域，是为了作用域结束后让可变借用失效，这样 `println` 才可以成功访问并打印我们期待的内容。
