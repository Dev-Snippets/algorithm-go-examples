# 引用与借用

Owership 让我们改变一个变量的值变得“复杂”，那能否像其他编程语言那样随意改变变量的值呢？答案是有的。所有权系统允许我们通过“Borrowing”的方式达到这个目的。这个机制非常像其他编程语言中的“读写锁”，即同一时刻，只能拥有一个“写锁”，或只能拥有多个“读锁”，不允许“写锁”和“读锁”在同一时刻同时出现。当然这也是数据读写过程中保障一致性的典型做法。只不过 Rust 是在编译中完成这个(Borrowing)检查的，而不是在运行时，这也就是为什么其他语言程序在运行过程中，容易出现死锁或者野指针的问题。

通过 & 符号完成 Borrowing：

```rust
fn main() {
	let x: Vec<i32> = vec![1i32, 2, 3];
	let y = &x;
	println!("x={:?}, y={:?}", x, y);
}
```

Borrowing(**&x**)并不会发生所有权 moved，所以 println 可以同时访问 x 和 y。通过引用，就可以对普通类型完成修改。

```rust
fn main() {
	let mut x: i32 = 100;
	{
		let y: &mut i32 = &mut x;
		*y += 2;
	}
	println!("{}", x);
}
```

借用与引用是一种相辅相成的关系，若 B 是对 A 的引用，也可称之为 B 借用了 A。

- 同一作用域，特定数据最多只有一个可变借用（&mut T），或者 2。
- 同一作用域，特定数据可有 0 个或多个不可变借用（&T），但不能有任何可变借用。
- 借用在离开作用域后释放。
- 在可变借用释放前不可访问源变量。

# 可变性

Borrowing 也分“不可变借用”（默认，**&T**）和“可变借用”（**&mut T**）。顾名思义，“不可变借用”是只读的，不可更新被引用的内容。

```rust
fn main() {
	let x: Vec<i32> = vec!(1i32, 2, 3);

	//可同时有多个不可变借用
	let y = &x;
	let z = &x;
	let m = &x;

	//ok
	println!("{:?}, {:?}, {:?}, {:?}", x, y, z, m);
}
```

再次强调下，同一作用域下只能有一个可变借用(&mut T)，且被借用的变量本身必须有可变性：

```rust
fn main() {
	//源变量x可变性
	let mut x: Vec<i32> = vec!(1i32, 2, 3);

	//只能有一个可变借用
	let y = &mut x;
	// let z = &mut x; //错误
    y.push(100);

	//ok
	println!("{:?}", y);

	//错误，可变借用未释放，源变量不可访问
	// println!("{:?}", x);
}  //y在此处销毁
```

- 借用不改变内存的所有者（Owner），借用只是对源内存的临时引用。
- 在借用周期内，借用方可以读写这块内存，所有者被禁止读写内存；且所有者保证在有“借用”存在的情况下，不会释放或转移内存。
- 失去所有权的变量不可以被借用（访问）。
- 在租借期内，内存所有者保证不会释放/转移/可变租借这块内存，但如果是在**非可变租借**的情况下，所有者是允许继续**非可变租借**出去的。
- 借用周期满后，所有者收回读写权限
- 借用周期小于被借用者（所有者）的生命周期。

```rust
fn main() {
	let mut x: Vec<i32> = vec!(1i32, 2, 3);

	//更新数组
	// push 中对数组进行了可变借用，并在 push 函数退出时销毁这个借用
    x.push(10);

    {
	    // 可变借用 1
	    let mut y = &mut x;
        y.push(100);

        // 可变借用 2，注意：此处是对 y 的借用，不可再对 x 进行借用，
        // 因为 y 在此时依然存活。
        let z = &mut y;
        z.push(1000);

	    println!("{:?}", z); //打印: [1, 2, 3, 10, 100, 1000]
    } // y 和 z 在此处被销毁，并释放借用。


	//访问x正常
	println!("{:?}", x); //打印: [1, 2, 3, 10, 100, 1000]
}
```
